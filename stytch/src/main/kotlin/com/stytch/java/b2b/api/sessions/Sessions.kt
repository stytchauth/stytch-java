package com.stytch.java.b2b.api.sessions

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.Moshi
import com.squareup.moshi.Types
import com.stytch.java.b2b.models.sessions.AuthenticateRequest
import com.stytch.java.b2b.models.sessions.AuthenticateResponse
import com.stytch.java.b2b.models.sessions.ExchangeRequest
import com.stytch.java.b2b.models.sessions.ExchangeResponse
import com.stytch.java.b2b.models.sessions.GetJWKSRequest
import com.stytch.java.b2b.models.sessions.GetJWKSResponse
import com.stytch.java.b2b.models.sessions.GetRequest
import com.stytch.java.b2b.models.sessions.GetResponse
import com.stytch.java.b2b.models.sessions.RevokeRequest
import com.stytch.java.b2b.models.sessions.RevokeResponse
import com.stytch.java.common.InstantAdapter
import com.stytch.java.common.JwtOptions
import com.stytch.java.common.StytchResult
import com.stytch.java.http.HttpClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.future.asCompletableFuture
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.jose4j.jwk.HttpsJwks
import java.util.concurrent.CompletableFuture
public interface Sessions {
    /**
     * Retrieves all active Sessions for a Member.
     */
    public suspend fun get(data: GetRequest): StytchResult<GetResponse>

    /**
     * Retrieves all active Sessions for a Member.
     */
    public fun get(data: GetRequest, callback: (StytchResult<GetResponse>) -> Unit)

    /**
     * Retrieves all active Sessions for a Member.
     */
    public fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>>

    /**
     * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
     * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires either a
     * `session_jwt` or `session_token` be included in the request. It will return an error if both are present.
     *
     * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT will be
     * returned if both the signature and the underlying Session are still valid.
     */
    public suspend fun authenticate(data: AuthenticateRequest): StytchResult<AuthenticateResponse>

    /**
     * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
     * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires either a
     * `session_jwt` or `session_token` be included in the request. It will return an error if both are present.
     *
     * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT will be
     * returned if both the signature and the underlying Session are still valid.
     */
    public fun authenticate(data: AuthenticateRequest, callback: (StytchResult<AuthenticateResponse>) -> Unit)

    /**
     * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
     * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires either a
     * `session_jwt` or `session_token` be included in the request. It will return an error if both are present.
     *
     * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT will be
     * returned if both the signature and the underlying Session are still valid.
     */
    public fun authenticateCompletable(data: AuthenticateRequest): CompletableFuture<StytchResult<AuthenticateResponse>>

    /**
     * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either the
     * `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass the `member_id`.
     */
    public suspend fun revoke(data: RevokeRequest): StytchResult<RevokeResponse>

    /**
     * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either the
     * `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass the `member_id`.
     */
    public fun revoke(data: RevokeRequest, callback: (StytchResult<RevokeResponse>) -> Unit)

    /**
     * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either the
     * `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass the `member_id`.
     */
    public fun revokeCompletable(data: RevokeRequest): CompletableFuture<StytchResult<RevokeResponse>>

    /**
     * Use this endpoint to exchange a Member's existing session for another session in a different Organization. This can be
     * used to accept an invite, but not to create a new member via domain matching.
     *
     * To create a new member via domain matching, use the
     * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow instead.
     *
     * Only Email Magic Link, OAuth, and SMS OTP factors can be transferred between sessions. Other authentication factors,
     * such as password factors, will not be transferred to the new session.
     * SMS OTP factors can be used to fulfill MFA requirements for the target Organization if both the original and target
     * Member have the same phone number and the phone number is verified for both Members.
     *
     * If the Member is required to complete MFA to log in to the Organization, the returned value of `member_authenticated`
     * will be `false`, and an `intermediate_session_token` will be returned.
     * The `intermediate_session_token` can be passed into the
     * [OTP SMS Authenticate endpoint](https://stytch.com/docs/b2b/api/authenticate-otp-sms) to complete the MFA step and
     * acquire a full member session.
     * The `intermediate_session_token` can also be used with the
     * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session) or the
     * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join
     * a different Organization or create a new one.
     * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.
     */
    public suspend fun exchange(data: ExchangeRequest): StytchResult<ExchangeResponse>

    /**
     * Use this endpoint to exchange a Member's existing session for another session in a different Organization. This can be
     * used to accept an invite, but not to create a new member via domain matching.
     *
     * To create a new member via domain matching, use the
     * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow instead.
     *
     * Only Email Magic Link, OAuth, and SMS OTP factors can be transferred between sessions. Other authentication factors,
     * such as password factors, will not be transferred to the new session.
     * SMS OTP factors can be used to fulfill MFA requirements for the target Organization if both the original and target
     * Member have the same phone number and the phone number is verified for both Members.
     *
     * If the Member is required to complete MFA to log in to the Organization, the returned value of `member_authenticated`
     * will be `false`, and an `intermediate_session_token` will be returned.
     * The `intermediate_session_token` can be passed into the
     * [OTP SMS Authenticate endpoint](https://stytch.com/docs/b2b/api/authenticate-otp-sms) to complete the MFA step and
     * acquire a full member session.
     * The `intermediate_session_token` can also be used with the
     * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session) or the
     * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join
     * a different Organization or create a new one.
     * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.
     */
    public fun exchange(data: ExchangeRequest, callback: (StytchResult<ExchangeResponse>) -> Unit)

    /**
     * Use this endpoint to exchange a Member's existing session for another session in a different Organization. This can be
     * used to accept an invite, but not to create a new member via domain matching.
     *
     * To create a new member via domain matching, use the
     * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow instead.
     *
     * Only Email Magic Link, OAuth, and SMS OTP factors can be transferred between sessions. Other authentication factors,
     * such as password factors, will not be transferred to the new session.
     * SMS OTP factors can be used to fulfill MFA requirements for the target Organization if both the original and target
     * Member have the same phone number and the phone number is verified for both Members.
     *
     * If the Member is required to complete MFA to log in to the Organization, the returned value of `member_authenticated`
     * will be `false`, and an `intermediate_session_token` will be returned.
     * The `intermediate_session_token` can be passed into the
     * [OTP SMS Authenticate endpoint](https://stytch.com/docs/b2b/api/authenticate-otp-sms) to complete the MFA step and
     * acquire a full member session.
     * The `intermediate_session_token` can also be used with the
     * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session) or the
     * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join
     * a different Organization or create a new one.
     * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.
     */
    public fun exchangeCompletable(data: ExchangeRequest): CompletableFuture<StytchResult<ExchangeResponse>>

    /**
     * Get the JSON Web Key Set (JWKS) for a project.
     */
    public suspend fun getJWKS(data: GetJWKSRequest): StytchResult<GetJWKSResponse>

    /**
     * Get the JSON Web Key Set (JWKS) for a project.
     */
    public fun getJWKS(data: GetJWKSRequest, callback: (StytchResult<GetJWKSResponse>) -> Unit)

    /**
     * Get the JSON Web Key Set (JWKS) for a project.
     */
    public fun getJWKSCompletable(data: GetJWKSRequest): CompletableFuture<StytchResult<GetJWKSResponse>>
}

internal class SessionsImpl(
    private val httpClient: HttpClient,
    private val coroutineScope: CoroutineScope,
    private val jwksClient: HttpsJwks,
    private val jwtOptions: JwtOptions,
) : Sessions {

    private val moshi = Moshi.Builder().add(InstantAdapter()).build()

    override suspend fun get(data: GetRequest): StytchResult<GetResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(GetRequest::class.java).toJson(data)
        val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
        val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
        val asMap = adapter.fromJson(asJson) ?: emptyMap()
        httpClient.get("/v1/b2b/sessions", asMap)
    }

    override fun get(data: GetRequest, callback: (StytchResult<GetResponse>) -> Unit) {
        coroutineScope.launch {
            callback(get(data))
        }
    }

    override fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>> =
        coroutineScope.async {
            get(data)
        }.asCompletableFuture()
    override suspend fun authenticate(data: AuthenticateRequest): StytchResult<AuthenticateResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(AuthenticateRequest::class.java).toJson(data)
        httpClient.post("/v1/b2b/sessions/authenticate", asJson)
    }

    override fun authenticate(data: AuthenticateRequest, callback: (StytchResult<AuthenticateResponse>) -> Unit) {
        coroutineScope.launch {
            callback(authenticate(data))
        }
    }

    override fun authenticateCompletable(data: AuthenticateRequest): CompletableFuture<StytchResult<AuthenticateResponse>> =
        coroutineScope.async {
            authenticate(data)
        }.asCompletableFuture()
    override suspend fun revoke(data: RevokeRequest): StytchResult<RevokeResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(RevokeRequest::class.java).toJson(data)
        httpClient.post("/v1/b2b/sessions/revoke", asJson)
    }

    override fun revoke(data: RevokeRequest, callback: (StytchResult<RevokeResponse>) -> Unit) {
        coroutineScope.launch {
            callback(revoke(data))
        }
    }

    override fun revokeCompletable(data: RevokeRequest): CompletableFuture<StytchResult<RevokeResponse>> =
        coroutineScope.async {
            revoke(data)
        }.asCompletableFuture()
    override suspend fun exchange(data: ExchangeRequest): StytchResult<ExchangeResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(ExchangeRequest::class.java).toJson(data)
        httpClient.post("/v1/b2b/sessions/exchange", asJson)
    }

    override fun exchange(data: ExchangeRequest, callback: (StytchResult<ExchangeResponse>) -> Unit) {
        coroutineScope.launch {
            callback(exchange(data))
        }
    }

    override fun exchangeCompletable(data: ExchangeRequest): CompletableFuture<StytchResult<ExchangeResponse>> =
        coroutineScope.async {
            exchange(data)
        }.asCompletableFuture()
    override suspend fun getJWKS(data: GetJWKSRequest): StytchResult<GetJWKSResponse> = withContext(Dispatchers.IO) {
        val asJson = moshi.adapter(GetJWKSRequest::class.java).toJson(data)
        val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
        val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
        val asMap = adapter.fromJson(asJson) ?: emptyMap()
        httpClient.get("/v1/b2b/sessions/jwks/${data.projectId}", asMap)
    }

    override fun getJWKS(data: GetJWKSRequest, callback: (StytchResult<GetJWKSResponse>) -> Unit) {
        coroutineScope.launch {
            callback(getJWKS(data))
        }
    }

    override fun getJWKSCompletable(data: GetJWKSRequest): CompletableFuture<StytchResult<GetJWKSResponse>> =
        coroutineScope.async {
            getJWKS(data)
        }.asCompletableFuture()
}
