package com.stytch.java.b2b.api.organizations

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.Moshi
import com.squareup.moshi.Types
import com.stytch.java.b2b.api.organizationsmembers.Members
import com.stytch.java.b2b.api.organizationsmembers.MembersImpl
import com.stytch.java.b2b.models.organizations.ConnectedAppsRequest
import com.stytch.java.b2b.models.organizations.ConnectedAppsRequestOptions
import com.stytch.java.b2b.models.organizations.ConnectedAppsResponse
import com.stytch.java.b2b.models.organizations.CreateRequest
import com.stytch.java.b2b.models.organizations.CreateResponse
import com.stytch.java.b2b.models.organizations.DeleteRequest
import com.stytch.java.b2b.models.organizations.DeleteRequestOptions
import com.stytch.java.b2b.models.organizations.DeleteResponse
import com.stytch.java.b2b.models.organizations.GetConnectedAppRequest
import com.stytch.java.b2b.models.organizations.GetConnectedAppRequestOptions
import com.stytch.java.b2b.models.organizations.GetConnectedAppResponse
import com.stytch.java.b2b.models.organizations.GetRequest
import com.stytch.java.b2b.models.organizations.GetResponse
import com.stytch.java.b2b.models.organizations.MetricsRequest
import com.stytch.java.b2b.models.organizations.MetricsResponse
import com.stytch.java.b2b.models.organizations.SearchRequest
import com.stytch.java.b2b.models.organizations.SearchResponse
import com.stytch.java.b2b.models.organizations.UpdateRequest
import com.stytch.java.b2b.models.organizations.UpdateRequestOptions
import com.stytch.java.b2b.models.organizations.UpdateResponse
import com.stytch.java.common.InstantAdapter
import com.stytch.java.common.StytchResult
import com.stytch.java.http.HttpClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.future.asCompletableFuture
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.CompletableFuture

public interface Organizations {
    public val members: Members

    /**
     * Creates an Organization. An `organization_name` and a unique `organization_slug` are required.
     *
     * By default, `email_invites` and `sso_jit_provisioning` will be set to `ALL_ALLOWED`, and `mfa_policy` will be set to
     * `OPTIONAL` if no Organization authentication settings are explicitly defined in the request.
     *
     * *See the [Organization authentication settings](https://stytch.com/docs/b2b/api/org-auth-settings) resource to learn
     * more about fields like `email_jit_provisioning`, `email_invites`, `sso_jit_provisioning`, etc., and their behaviors.
     */
    public suspend fun create(data: CreateRequest): StytchResult<CreateResponse>

    /**
     * Creates an Organization. An `organization_name` and a unique `organization_slug` are required.
     *
     * By default, `email_invites` and `sso_jit_provisioning` will be set to `ALL_ALLOWED`, and `mfa_policy` will be set to
     * `OPTIONAL` if no Organization authentication settings are explicitly defined in the request.
     *
     * *See the [Organization authentication settings](https://stytch.com/docs/b2b/api/org-auth-settings) resource to learn
     * more about fields like `email_jit_provisioning`, `email_invites`, `sso_jit_provisioning`, etc., and their behaviors.
     */
    public fun create(
        data: CreateRequest,
        callback: (StytchResult<CreateResponse>) -> Unit,
    )

    /**
     * Creates an Organization. An `organization_name` and a unique `organization_slug` are required.
     *
     * By default, `email_invites` and `sso_jit_provisioning` will be set to `ALL_ALLOWED`, and `mfa_policy` will be set to
     * `OPTIONAL` if no Organization authentication settings are explicitly defined in the request.
     *
     * *See the [Organization authentication settings](https://stytch.com/docs/b2b/api/org-auth-settings) resource to learn
     * more about fields like `email_jit_provisioning`, `email_invites`, `sso_jit_provisioning`, etc., and their behaviors.
     */
    public fun createCompletable(data: CreateRequest): CompletableFuture<StytchResult<CreateResponse>>

    /**
     * Returns an Organization specified by `organization_id`.
     */
    public suspend fun get(data: GetRequest): StytchResult<GetResponse>

    /**
     * Returns an Organization specified by `organization_id`.
     */
    public fun get(
        data: GetRequest,
        callback: (StytchResult<GetResponse>) -> Unit,
    )

    /**
     * Returns an Organization specified by `organization_id`.
     */
    public fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>>

    /**
     * Updates an Organization specified by `organization_id`. An Organization must always have at least one auth setting set
     * to either `RESTRICTED` or `ALL_ALLOWED` in order to provision new Members.
     *
     * *See the [Organization authentication settings](https://stytch.com/docs/b2b/api/org-auth-settings) resource to learn
     * more about fields like `email_jit_provisioning`, `email_invites`, `sso_jit_provisioning`, etc., and their behaviors.
     */
    public suspend fun update(
        data: UpdateRequest,
        methodOptions: UpdateRequestOptions? = null,
    ): StytchResult<UpdateResponse>

    /**
     * Updates an Organization specified by `organization_id`. An Organization must always have at least one auth setting set
     * to either `RESTRICTED` or `ALL_ALLOWED` in order to provision new Members.
     *
     * *See the [Organization authentication settings](https://stytch.com/docs/b2b/api/org-auth-settings) resource to learn
     * more about fields like `email_jit_provisioning`, `email_invites`, `sso_jit_provisioning`, etc., and their behaviors.
     */
    public fun update(
        data: UpdateRequest,
        methodOptions: UpdateRequestOptions? = null,
        callback: (StytchResult<UpdateResponse>) -> Unit,
    )

    /**
     * Updates an Organization specified by `organization_id`. An Organization must always have at least one auth setting set
     * to either `RESTRICTED` or `ALL_ALLOWED` in order to provision new Members.
     *
     * *See the [Organization authentication settings](https://stytch.com/docs/b2b/api/org-auth-settings) resource to learn
     * more about fields like `email_jit_provisioning`, `email_invites`, `sso_jit_provisioning`, etc., and their behaviors.
     */
    public fun updateCompletable(
        data: UpdateRequest,
        methodOptions: UpdateRequestOptions? = null,
    ): CompletableFuture<StytchResult<UpdateResponse>>

    /**
     * Deletes an Organization specified by `organization_id`. All Members of the Organization will also be deleted.
     */
    public suspend fun delete(
        data: DeleteRequest,
        methodOptions: DeleteRequestOptions? = null,
    ): StytchResult<DeleteResponse>

    /**
     * Deletes an Organization specified by `organization_id`. All Members of the Organization will also be deleted.
     */
    public fun delete(
        data: DeleteRequest,
        methodOptions: DeleteRequestOptions? = null,
        callback: (StytchResult<DeleteResponse>) -> Unit,
    )

    /**
     * Deletes an Organization specified by `organization_id`. All Members of the Organization will also be deleted.
     */
    public fun deleteCompletable(
        data: DeleteRequest,
        methodOptions: DeleteRequestOptions? = null,
    ): CompletableFuture<StytchResult<DeleteResponse>>

    /**
     * Search for Organizations. If you send a request with no body params, no filtering will be applied and the endpoint will
     * return all Organizations. All fuzzy search filters require a minimum of three characters.
     */
    public suspend fun search(data: SearchRequest): StytchResult<SearchResponse>

    /**
     * Search for Organizations. If you send a request with no body params, no filtering will be applied and the endpoint will
     * return all Organizations. All fuzzy search filters require a minimum of three characters.
     */
    public fun search(
        data: SearchRequest,
        callback: (StytchResult<SearchResponse>) -> Unit,
    )

    /**
     * Search for Organizations. If you send a request with no body params, no filtering will be applied and the endpoint will
     * return all Organizations. All fuzzy search filters require a minimum of three characters.
     */
    public fun searchCompletable(data: SearchRequest): CompletableFuture<StytchResult<SearchResponse>>

    public suspend fun metrics(data: MetricsRequest): StytchResult<MetricsResponse>

    public fun metrics(
        data: MetricsRequest,
        callback: (StytchResult<MetricsResponse>) -> Unit,
    )

    public fun metricsCompletable(data: MetricsRequest): CompletableFuture<StytchResult<MetricsResponse>>

    /**
     * Retrieves a list of Connected Apps for the Organization that have been installed by Members. Installation comprises
     * successful completion of an authorization flow with a Connected App that has not been revoked.
     *
     * Connected Apps may be uninstalled if an Organization changes its `first_party_connected_apps_allowed_type`
     * or `third_party_connected_apps_allowed_type` policies.
     */
    public suspend fun connectedApps(
        data: ConnectedAppsRequest,
        methodOptions: ConnectedAppsRequestOptions? = null,
    ): StytchResult<ConnectedAppsResponse>

    /**
     * Retrieves a list of Connected Apps for the Organization that have been installed by Members. Installation comprises
     * successful completion of an authorization flow with a Connected App that has not been revoked.
     *
     * Connected Apps may be uninstalled if an Organization changes its `first_party_connected_apps_allowed_type`
     * or `third_party_connected_apps_allowed_type` policies.
     */
    public fun connectedApps(
        data: ConnectedAppsRequest,
        methodOptions: ConnectedAppsRequestOptions? = null,
        callback: (StytchResult<ConnectedAppsResponse>) -> Unit,
    )

    /**
     * Retrieves a list of Connected Apps for the Organization that have been installed by Members. Installation comprises
     * successful completion of an authorization flow with a Connected App that has not been revoked.
     *
     * Connected Apps may be uninstalled if an Organization changes its `first_party_connected_apps_allowed_type`
     * or `third_party_connected_apps_allowed_type` policies.
     */
    public fun connectedAppsCompletable(
        data: ConnectedAppsRequest,
        methodOptions: ConnectedAppsRequestOptions? = null,
    ): CompletableFuture<StytchResult<ConnectedAppsResponse>>

    /**
     * Get Connected App for Organization retrieves information about the specified Connected App as well as a list of the
     * Organization's Members who have the App installed along with the scopes they requested at completion of their last
     * authorization with the App.
     */
    public suspend fun getConnectedApp(
        data: GetConnectedAppRequest,
        methodOptions: GetConnectedAppRequestOptions? = null,
    ): StytchResult<GetConnectedAppResponse>

    /**
     * Get Connected App for Organization retrieves information about the specified Connected App as well as a list of the
     * Organization's Members who have the App installed along with the scopes they requested at completion of their last
     * authorization with the App.
     */
    public fun getConnectedApp(
        data: GetConnectedAppRequest,
        methodOptions: GetConnectedAppRequestOptions? = null,
        callback: (StytchResult<GetConnectedAppResponse>) -> Unit,
    )

    /**
     * Get Connected App for Organization retrieves information about the specified Connected App as well as a list of the
     * Organization's Members who have the App installed along with the scopes they requested at completion of their last
     * authorization with the App.
     */
    public fun getConnectedAppCompletable(
        data: GetConnectedAppRequest,
        methodOptions: GetConnectedAppRequestOptions? = null,
    ): CompletableFuture<StytchResult<GetConnectedAppResponse>>
}

internal class OrganizationsImpl(
    private val httpClient: HttpClient,
    private val coroutineScope: CoroutineScope,
) : Organizations {
    private val moshi = Moshi.Builder().add(InstantAdapter()).build()

    override val members: Members = MembersImpl(httpClient, coroutineScope)

    override suspend fun create(data: CreateRequest): StytchResult<CreateResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(CreateRequest::class.java).toJson(data)
            httpClient.post("/v1/b2b/organizations", asJson, headers)
        }

    override fun create(
        data: CreateRequest,
        callback: (StytchResult<CreateResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(create(data))
        }
    }

    override fun createCompletable(data: CreateRequest): CompletableFuture<StytchResult<CreateResponse>> =
        coroutineScope.async {
            create(data)
        }.asCompletableFuture()

    override suspend fun get(data: GetRequest): StytchResult<GetResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(GetRequest::class.java).toJson(data)
            val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
            val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
            val asMap = adapter.fromJson(asJson) ?: emptyMap()
            httpClient.get("/v1/b2b/organizations/${data.organizationId}", asMap, headers)
        }

    override fun get(
        data: GetRequest,
        callback: (StytchResult<GetResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(get(data))
        }
    }

    override fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>> =
        coroutineScope.async {
            get(data)
        }.asCompletableFuture()

    override suspend fun update(
        data: UpdateRequest,
        methodOptions: UpdateRequestOptions?,
    ): StytchResult<UpdateResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()
            methodOptions?.let {
                headers = methodOptions.addHeaders(headers)
            }

            val asJson = moshi.adapter(UpdateRequest::class.java).toJson(data)
            httpClient.put("/v1/b2b/organizations/${data.organizationId}", asJson, headers)
        }

    override fun update(
        data: UpdateRequest,
        methodOptions: UpdateRequestOptions?,
        callback: (StytchResult<UpdateResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(update(data, methodOptions))
        }
    }

    override fun updateCompletable(
        data: UpdateRequest,
        methodOptions: UpdateRequestOptions?,
    ): CompletableFuture<StytchResult<UpdateResponse>> =
        coroutineScope.async {
            update(data, methodOptions)
        }.asCompletableFuture()

    override suspend fun delete(
        data: DeleteRequest,
        methodOptions: DeleteRequestOptions?,
    ): StytchResult<DeleteResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()
            methodOptions?.let {
                headers = methodOptions.addHeaders(headers)
            }

            httpClient.delete("/v1/b2b/organizations/${data.organizationId}", headers)
        }

    override fun delete(
        data: DeleteRequest,
        methodOptions: DeleteRequestOptions?,
        callback: (StytchResult<DeleteResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(delete(data, methodOptions))
        }
    }

    override fun deleteCompletable(
        data: DeleteRequest,
        methodOptions: DeleteRequestOptions?,
    ): CompletableFuture<StytchResult<DeleteResponse>> =
        coroutineScope.async {
            delete(data, methodOptions)
        }.asCompletableFuture()

    override suspend fun search(data: SearchRequest): StytchResult<SearchResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(SearchRequest::class.java).toJson(data)
            httpClient.post("/v1/b2b/organizations/search", asJson, headers)
        }

    override fun search(
        data: SearchRequest,
        callback: (StytchResult<SearchResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(search(data))
        }
    }

    override fun searchCompletable(data: SearchRequest): CompletableFuture<StytchResult<SearchResponse>> =
        coroutineScope.async {
            search(data)
        }.asCompletableFuture()

    override suspend fun metrics(data: MetricsRequest): StytchResult<MetricsResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(MetricsRequest::class.java).toJson(data)
            val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
            val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
            val asMap = adapter.fromJson(asJson) ?: emptyMap()
            httpClient.get("/v1/b2b/organizations/${data.organizationId}/metrics", asMap, headers)
        }

    override fun metrics(
        data: MetricsRequest,
        callback: (StytchResult<MetricsResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(metrics(data))
        }
    }

    override fun metricsCompletable(data: MetricsRequest): CompletableFuture<StytchResult<MetricsResponse>> =
        coroutineScope.async {
            metrics(data)
        }.asCompletableFuture()

    override suspend fun connectedApps(
        data: ConnectedAppsRequest,
        methodOptions: ConnectedAppsRequestOptions?,
    ): StytchResult<ConnectedAppsResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()
            methodOptions?.let {
                headers = methodOptions.addHeaders(headers)
            }

            val asJson = moshi.adapter(ConnectedAppsRequest::class.java).toJson(data)
            val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
            val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
            val asMap = adapter.fromJson(asJson) ?: emptyMap()
            httpClient.get("/v1/b2b/organizations/${data.organizationId}/connected_apps", asMap, headers)
        }

    override fun connectedApps(
        data: ConnectedAppsRequest,
        methodOptions: ConnectedAppsRequestOptions?,
        callback: (StytchResult<ConnectedAppsResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(connectedApps(data, methodOptions))
        }
    }

    override fun connectedAppsCompletable(
        data: ConnectedAppsRequest,
        methodOptions: ConnectedAppsRequestOptions?,
    ): CompletableFuture<StytchResult<ConnectedAppsResponse>> =
        coroutineScope.async {
            connectedApps(data, methodOptions)
        }.asCompletableFuture()

    override suspend fun getConnectedApp(
        data: GetConnectedAppRequest,
        methodOptions: GetConnectedAppRequestOptions?,
    ): StytchResult<GetConnectedAppResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()
            methodOptions?.let {
                headers = methodOptions.addHeaders(headers)
            }

            val asJson = moshi.adapter(GetConnectedAppRequest::class.java).toJson(data)
            val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
            val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
            val asMap = adapter.fromJson(asJson) ?: emptyMap()
            httpClient.get("/v1/b2b/organizations/${data.organizationId}/connected_apps/${data.connectedAppId}", asMap, headers)
        }

    override fun getConnectedApp(
        data: GetConnectedAppRequest,
        methodOptions: GetConnectedAppRequestOptions?,
        callback: (StytchResult<GetConnectedAppResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(getConnectedApp(data, methodOptions))
        }
    }

    override fun getConnectedAppCompletable(
        data: GetConnectedAppRequest,
        methodOptions: GetConnectedAppRequestOptions?,
    ): CompletableFuture<StytchResult<GetConnectedAppResponse>> =
        coroutineScope.async {
            getConnectedApp(data, methodOptions)
        }.asCompletableFuture()
}
