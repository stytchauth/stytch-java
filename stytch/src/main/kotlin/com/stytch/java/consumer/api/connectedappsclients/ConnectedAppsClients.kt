package com.stytch.java.consumer.api.connectedappsclients

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.Moshi
import com.squareup.moshi.Types
import com.stytch.java.common.InstantAdapter
import com.stytch.java.common.StytchResult
import com.stytch.java.consumer.api.connectedappsclientssecrets.Secrets
import com.stytch.java.consumer.api.connectedappsclientssecrets.SecretsImpl
import com.stytch.java.consumer.models.connectedappsclients.CreateRequest
import com.stytch.java.consumer.models.connectedappsclients.CreateResponse
import com.stytch.java.consumer.models.connectedappsclients.DeleteRequest
import com.stytch.java.consumer.models.connectedappsclients.DeleteResponse
import com.stytch.java.consumer.models.connectedappsclients.GetRequest
import com.stytch.java.consumer.models.connectedappsclients.GetResponse
import com.stytch.java.consumer.models.connectedappsclients.SearchRequest
import com.stytch.java.consumer.models.connectedappsclients.SearchResponse
import com.stytch.java.consumer.models.connectedappsclients.UpdateRequest
import com.stytch.java.consumer.models.connectedappsclients.UpdateResponse
import com.stytch.java.http.HttpClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.future.asCompletableFuture
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.CompletableFuture

public interface Clients {
    public val secrets: Secrets

    /**
     * Retrieve details of a specific Connected App by `client_id`.
     */
    public suspend fun get(data: GetRequest): StytchResult<GetResponse>

    /**
     * Retrieve details of a specific Connected App by `client_id`.
     */
    public fun get(
        data: GetRequest,
        callback: (StytchResult<GetResponse>) -> Unit,
    )

    /**
     * Retrieve details of a specific Connected App by `client_id`.
     */
    public fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>>

    /**
     * Updates mutable fields of a Connected App. Cannot update Client Type, Client ID, or Secrets.
     */
    public suspend fun update(data: UpdateRequest): StytchResult<UpdateResponse>

    /**
     * Updates mutable fields of a Connected App. Cannot update Client Type, Client ID, or Secrets.
     */
    public fun update(
        data: UpdateRequest,
        callback: (StytchResult<UpdateResponse>) -> Unit,
    )

    /**
     * Updates mutable fields of a Connected App. Cannot update Client Type, Client ID, or Secrets.
     */
    public fun updateCompletable(data: UpdateRequest): CompletableFuture<StytchResult<UpdateResponse>>

    /**
     * Deletes a Connected App.
     */
    public suspend fun delete(data: DeleteRequest): StytchResult<DeleteResponse>

    /**
     * Deletes a Connected App.
     */
    public fun delete(
        data: DeleteRequest,
        callback: (StytchResult<DeleteResponse>) -> Unit,
    )

    /**
     * Deletes a Connected App.
     */
    public fun deleteCompletable(data: DeleteRequest): CompletableFuture<StytchResult<DeleteResponse>>

    /**
     * Search for Connected Apps. Supports cursor-based pagination. Specific filters coming soon.
     */
    public suspend fun search(data: SearchRequest): StytchResult<SearchResponse>

    /**
     * Search for Connected Apps. Supports cursor-based pagination. Specific filters coming soon.
     */
    public fun search(
        data: SearchRequest,
        callback: (StytchResult<SearchResponse>) -> Unit,
    )

    /**
     * Search for Connected Apps. Supports cursor-based pagination. Specific filters coming soon.
     */
    public fun searchCompletable(data: SearchRequest): CompletableFuture<StytchResult<SearchResponse>>

    /**
     * Creates a new Connected App. If the Connected App `client_type` is `first_party` or `third_party` a `client_secret` is
     * returned.
     *
     * **Important:** This is the only time you will be able to view the generated `client_secret` in the API response. Stytch
     * stores a hash of the `client_secret` and cannot recover the value if lost. Be sure to persist the `client_secret` in a
     * secure location. If the `client_secret` is lost, you will need to trigger a secret rotation flow to receive another one.
     */
    public suspend fun create(data: CreateRequest): StytchResult<CreateResponse>

    /**
     * Creates a new Connected App. If the Connected App `client_type` is `first_party` or `third_party` a `client_secret` is
     * returned.
     *
     * **Important:** This is the only time you will be able to view the generated `client_secret` in the API response. Stytch
     * stores a hash of the `client_secret` and cannot recover the value if lost. Be sure to persist the `client_secret` in a
     * secure location. If the `client_secret` is lost, you will need to trigger a secret rotation flow to receive another one.
     */
    public fun create(
        data: CreateRequest,
        callback: (StytchResult<CreateResponse>) -> Unit,
    )

    /**
     * Creates a new Connected App. If the Connected App `client_type` is `first_party` or `third_party` a `client_secret` is
     * returned.
     *
     * **Important:** This is the only time you will be able to view the generated `client_secret` in the API response. Stytch
     * stores a hash of the `client_secret` and cannot recover the value if lost. Be sure to persist the `client_secret` in a
     * secure location. If the `client_secret` is lost, you will need to trigger a secret rotation flow to receive another one.
     */
    public fun createCompletable(data: CreateRequest): CompletableFuture<StytchResult<CreateResponse>>
}

internal class ClientsImpl(
    private val httpClient: HttpClient,
    private val coroutineScope: CoroutineScope,
) : Clients {
    private val moshi = Moshi.Builder().add(InstantAdapter()).build()

    override val secrets: Secrets = SecretsImpl(httpClient, coroutineScope)

    override suspend fun get(data: GetRequest): StytchResult<GetResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(GetRequest::class.java).toJson(data)
            val type = Types.newParameterizedType(Map::class.java, String::class.java, Any::class.java)
            val adapter: JsonAdapter<Map<String, Any>> = moshi.adapter(type)
            val asMap = adapter.fromJson(asJson) ?: emptyMap()
            httpClient.get("/v1/connected_apps/clients/${data.clientId}", asMap, headers)
        }

    override fun get(
        data: GetRequest,
        callback: (StytchResult<GetResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(get(data))
        }
    }

    override fun getCompletable(data: GetRequest): CompletableFuture<StytchResult<GetResponse>> =
        coroutineScope.async {
            get(data)
        }.asCompletableFuture()

    override suspend fun update(data: UpdateRequest): StytchResult<UpdateResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(UpdateRequest::class.java).toJson(data)
            httpClient.put("/v1/connected_apps/clients/${data.clientId}", asJson, headers)
        }

    override fun update(
        data: UpdateRequest,
        callback: (StytchResult<UpdateResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(update(data))
        }
    }

    override fun updateCompletable(data: UpdateRequest): CompletableFuture<StytchResult<UpdateResponse>> =
        coroutineScope.async {
            update(data)
        }.asCompletableFuture()

    override suspend fun delete(data: DeleteRequest): StytchResult<DeleteResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            httpClient.delete("/v1/connected_apps/clients/${data.clientId}", headers)
        }

    override fun delete(
        data: DeleteRequest,
        callback: (StytchResult<DeleteResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(delete(data))
        }
    }

    override fun deleteCompletable(data: DeleteRequest): CompletableFuture<StytchResult<DeleteResponse>> =
        coroutineScope.async {
            delete(data)
        }.asCompletableFuture()

    override suspend fun search(data: SearchRequest): StytchResult<SearchResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(SearchRequest::class.java).toJson(data)
            httpClient.post("/v1/connected_apps/clients/search", asJson, headers)
        }

    override fun search(
        data: SearchRequest,
        callback: (StytchResult<SearchResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(search(data))
        }
    }

    override fun searchCompletable(data: SearchRequest): CompletableFuture<StytchResult<SearchResponse>> =
        coroutineScope.async {
            search(data)
        }.asCompletableFuture()

    override suspend fun create(data: CreateRequest): StytchResult<CreateResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(CreateRequest::class.java).toJson(data)
            httpClient.post("/v1/connected_apps/clients", asJson, headers)
        }

    override fun create(
        data: CreateRequest,
        callback: (StytchResult<CreateResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(create(data))
        }
    }

    override fun createCompletable(data: CreateRequest): CompletableFuture<StytchResult<CreateResponse>> =
        coroutineScope.async {
            create(data)
        }.asCompletableFuture()
}
