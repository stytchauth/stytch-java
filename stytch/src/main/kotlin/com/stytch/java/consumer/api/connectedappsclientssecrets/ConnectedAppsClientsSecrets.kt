package com.stytch.java.consumer.api.connectedappsclientssecrets

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import com.squareup.moshi.Moshi
import com.stytch.java.common.InstantAdapter
import com.stytch.java.common.StytchResult
import com.stytch.java.consumer.models.connectedappsclientssecrets.RotateCancelRequest
import com.stytch.java.consumer.models.connectedappsclientssecrets.RotateCancelResponse
import com.stytch.java.consumer.models.connectedappsclientssecrets.RotateRequest
import com.stytch.java.consumer.models.connectedappsclientssecrets.RotateResponse
import com.stytch.java.consumer.models.connectedappsclientssecrets.RotateStartRequest
import com.stytch.java.consumer.models.connectedappsclientssecrets.RotateStartResponse
import com.stytch.java.http.HttpClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.future.asCompletableFuture
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.CompletableFuture

public interface Secrets {
    public suspend fun rotateStart(data: RotateStartRequest): StytchResult<RotateStartResponse>

    public fun rotateStart(
        data: RotateStartRequest,
        callback: (StytchResult<RotateStartResponse>) -> Unit,
    )

    public fun rotateStartCompletable(data: RotateStartRequest): CompletableFuture<StytchResult<RotateStartResponse>>

    public suspend fun rotateCancel(data: RotateCancelRequest): StytchResult<RotateCancelResponse>

    public fun rotateCancel(
        data: RotateCancelRequest,
        callback: (StytchResult<RotateCancelResponse>) -> Unit,
    )

    public fun rotateCancelCompletable(data: RotateCancelRequest): CompletableFuture<StytchResult<RotateCancelResponse>>

    public suspend fun rotate(data: RotateRequest): StytchResult<RotateResponse>

    public fun rotate(
        data: RotateRequest,
        callback: (StytchResult<RotateResponse>) -> Unit,
    )

    public fun rotateCompletable(data: RotateRequest): CompletableFuture<StytchResult<RotateResponse>>
}

internal class SecretsImpl(
    private val httpClient: HttpClient,
    private val coroutineScope: CoroutineScope,
) : Secrets {
    private val moshi = Moshi.Builder().add(InstantAdapter()).build()

    override suspend fun rotateStart(data: RotateStartRequest): StytchResult<RotateStartResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(RotateStartRequest::class.java).toJson(data)
            httpClient.post("/v1/connected_apps/clients/${data.clientId}/secrets/rotate/start", asJson, headers)
        }

    override fun rotateStart(
        data: RotateStartRequest,
        callback: (StytchResult<RotateStartResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(rotateStart(data))
        }
    }

    override fun rotateStartCompletable(data: RotateStartRequest): CompletableFuture<StytchResult<RotateStartResponse>> =
        coroutineScope.async {
            rotateStart(data)
        }.asCompletableFuture()

    override suspend fun rotateCancel(data: RotateCancelRequest): StytchResult<RotateCancelResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(RotateCancelRequest::class.java).toJson(data)
            httpClient.post("/v1/connected_apps/clients/${data.clientId}/secrets/rotate/cancel", asJson, headers)
        }

    override fun rotateCancel(
        data: RotateCancelRequest,
        callback: (StytchResult<RotateCancelResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(rotateCancel(data))
        }
    }

    override fun rotateCancelCompletable(data: RotateCancelRequest): CompletableFuture<StytchResult<RotateCancelResponse>> =
        coroutineScope.async {
            rotateCancel(data)
        }.asCompletableFuture()

    override suspend fun rotate(data: RotateRequest): StytchResult<RotateResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(RotateRequest::class.java).toJson(data)
            httpClient.post("/v1/connected_apps/clients/${data.clientId}/secrets/rotate", asJson, headers)
        }

    override fun rotate(
        data: RotateRequest,
        callback: (StytchResult<RotateResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(rotate(data))
        }
    }

    override fun rotateCompletable(data: RotateRequest): CompletableFuture<StytchResult<RotateResponse>> =
        coroutineScope.async {
            rotate(data)
        }.asCompletableFuture()
}
