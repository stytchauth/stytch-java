package com.stytch.java.consumer.api.idpoauth

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import com.squareup.moshi.Moshi
import com.stytch.java.common.InstantAdapter
import com.stytch.java.common.StytchResult
import com.stytch.java.consumer.models.idpoauth.AuthorizeRequest
import com.stytch.java.consumer.models.idpoauth.AuthorizeResponse
import com.stytch.java.consumer.models.idpoauth.AuthorizeStartRequest
import com.stytch.java.consumer.models.idpoauth.AuthorizeStartResponse
import com.stytch.java.http.HttpClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.future.asCompletableFuture
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.CompletableFuture

public interface OAuth {
    /**
     * Initiates a request for authorization of a Connected App to access a User's account.
     *
     * Call this endpoint using the query parameters from an OAuth Authorization request.
     * This endpoint validates various fields (`scope`, `client_id`, `redirect_uri`, `prompt`, etc...) are correct and returns
     * relevant information for rendering an OAuth Consent Screen.
     *
     * This endpoint returns:
     * - A public representation of the Connected App requesting authorization
     * - Whether _explicit_ user consent must be granted before proceeding with the authorization
     * - A list of scopes the user has the ability to grant the Connected App
     *
     * Use this response to prompt the user for consent (if necessary) before calling the
     * [Submit OAuth Authorization](https://stytch.com/docs/api/connected-apps-oauth-authorize) endpoint.
     *
     * Exactly one of the following must be provided to identify the user granting authorization:
     * - `user_id`
     * - `session_token`
     * - `session_jwt`
     *
     * If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for
     * tracking purposes.
     * One of these fields must be used if the Connected App intends to complete the
     * [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
     */
    public suspend fun authorizeStart(data: AuthorizeStartRequest): StytchResult<AuthorizeStartResponse>

    /**
     * Initiates a request for authorization of a Connected App to access a User's account.
     *
     * Call this endpoint using the query parameters from an OAuth Authorization request.
     * This endpoint validates various fields (`scope`, `client_id`, `redirect_uri`, `prompt`, etc...) are correct and returns
     * relevant information for rendering an OAuth Consent Screen.
     *
     * This endpoint returns:
     * - A public representation of the Connected App requesting authorization
     * - Whether _explicit_ user consent must be granted before proceeding with the authorization
     * - A list of scopes the user has the ability to grant the Connected App
     *
     * Use this response to prompt the user for consent (if necessary) before calling the
     * [Submit OAuth Authorization](https://stytch.com/docs/api/connected-apps-oauth-authorize) endpoint.
     *
     * Exactly one of the following must be provided to identify the user granting authorization:
     * - `user_id`
     * - `session_token`
     * - `session_jwt`
     *
     * If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for
     * tracking purposes.
     * One of these fields must be used if the Connected App intends to complete the
     * [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
     */
    public fun authorizeStart(
        data: AuthorizeStartRequest,
        callback: (StytchResult<AuthorizeStartResponse>) -> Unit,
    )

    /**
     * Initiates a request for authorization of a Connected App to access a User's account.
     *
     * Call this endpoint using the query parameters from an OAuth Authorization request.
     * This endpoint validates various fields (`scope`, `client_id`, `redirect_uri`, `prompt`, etc...) are correct and returns
     * relevant information for rendering an OAuth Consent Screen.
     *
     * This endpoint returns:
     * - A public representation of the Connected App requesting authorization
     * - Whether _explicit_ user consent must be granted before proceeding with the authorization
     * - A list of scopes the user has the ability to grant the Connected App
     *
     * Use this response to prompt the user for consent (if necessary) before calling the
     * [Submit OAuth Authorization](https://stytch.com/docs/api/connected-apps-oauth-authorize) endpoint.
     *
     * Exactly one of the following must be provided to identify the user granting authorization:
     * - `user_id`
     * - `session_token`
     * - `session_jwt`
     *
     * If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for
     * tracking purposes.
     * One of these fields must be used if the Connected App intends to complete the
     * [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
     */
    public fun authorizeStartCompletable(data: AuthorizeStartRequest): CompletableFuture<StytchResult<AuthorizeStartResponse>>

    /**
     * Completes a request for authorization of a Connected App to access a User's account.
     *
     * Call this endpoint using the query parameters from an OAuth Authorization request, after previously validating those
     * parameters using the
     * [Preflight Check](https://stytch.com/docs/api/connected-apps-oauth-authorize-start) API.
     * Note that this endpoint takes in a few additional parameters the preflight check does not- `state`, `nonce`, and
     * `code_challenge`.
     *
     * If the authorization was successful, the `redirect_uri` will contain a valid `authorization_code` embedded as a query
     * parameter.
     * If the authorization was unsuccessful, the `redirect_uri` will contain an OAuth2.1 `error_code`.
     * In both cases, redirect the user to the location for the response to be consumed by the Connected App.
     *
     * Exactly one of the following must be provided to identify the user granting authorization:
     * - `user_id`
     * - `session_token`
     * - `session_jwt`
     *
     * If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for
     * tracking purposes.
     * One of these fields must be used if the Connected App intends to complete the
     * [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
     */
    public suspend fun authorize(data: AuthorizeRequest): StytchResult<AuthorizeResponse>

    /**
     * Completes a request for authorization of a Connected App to access a User's account.
     *
     * Call this endpoint using the query parameters from an OAuth Authorization request, after previously validating those
     * parameters using the
     * [Preflight Check](https://stytch.com/docs/api/connected-apps-oauth-authorize-start) API.
     * Note that this endpoint takes in a few additional parameters the preflight check does not- `state`, `nonce`, and
     * `code_challenge`.
     *
     * If the authorization was successful, the `redirect_uri` will contain a valid `authorization_code` embedded as a query
     * parameter.
     * If the authorization was unsuccessful, the `redirect_uri` will contain an OAuth2.1 `error_code`.
     * In both cases, redirect the user to the location for the response to be consumed by the Connected App.
     *
     * Exactly one of the following must be provided to identify the user granting authorization:
     * - `user_id`
     * - `session_token`
     * - `session_jwt`
     *
     * If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for
     * tracking purposes.
     * One of these fields must be used if the Connected App intends to complete the
     * [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
     */
    public fun authorize(
        data: AuthorizeRequest,
        callback: (StytchResult<AuthorizeResponse>) -> Unit,
    )

    /**
     * Completes a request for authorization of a Connected App to access a User's account.
     *
     * Call this endpoint using the query parameters from an OAuth Authorization request, after previously validating those
     * parameters using the
     * [Preflight Check](https://stytch.com/docs/api/connected-apps-oauth-authorize-start) API.
     * Note that this endpoint takes in a few additional parameters the preflight check does not- `state`, `nonce`, and
     * `code_challenge`.
     *
     * If the authorization was successful, the `redirect_uri` will contain a valid `authorization_code` embedded as a query
     * parameter.
     * If the authorization was unsuccessful, the `redirect_uri` will contain an OAuth2.1 `error_code`.
     * In both cases, redirect the user to the location for the response to be consumed by the Connected App.
     *
     * Exactly one of the following must be provided to identify the user granting authorization:
     * - `user_id`
     * - `session_token`
     * - `session_jwt`
     *
     * If a `session_token` or `session_jwt` is passed, the OAuth Authorization will be linked to the user's session for
     * tracking purposes.
     * One of these fields must be used if the Connected App intends to complete the
     * [Exchange Access Token](https://stytch.com/docs/api/connected-app-access-token-exchange) flow.
     */
    public fun authorizeCompletable(data: AuthorizeRequest): CompletableFuture<StytchResult<AuthorizeResponse>>
}

internal class OAuthImpl(
    private val httpClient: HttpClient,
    private val coroutineScope: CoroutineScope,
) : OAuth {
    private val moshi = Moshi.Builder().add(InstantAdapter()).build()

    override suspend fun authorizeStart(data: AuthorizeStartRequest): StytchResult<AuthorizeStartResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(AuthorizeStartRequest::class.java).toJson(data)
            httpClient.post("/v1/idp/oauth/authorize/start", asJson, headers)
        }

    override fun authorizeStart(
        data: AuthorizeStartRequest,
        callback: (StytchResult<AuthorizeStartResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(authorizeStart(data))
        }
    }

    override fun authorizeStartCompletable(data: AuthorizeStartRequest): CompletableFuture<StytchResult<AuthorizeStartResponse>> =
        coroutineScope.async {
            authorizeStart(data)
        }.asCompletableFuture()

    override suspend fun authorize(data: AuthorizeRequest): StytchResult<AuthorizeResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(AuthorizeRequest::class.java).toJson(data)
            httpClient.post("/v1/idp/oauth/authorize", asJson, headers)
        }

    override fun authorize(
        data: AuthorizeRequest,
        callback: (StytchResult<AuthorizeResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(authorize(data))
        }
    }

    override fun authorizeCompletable(data: AuthorizeRequest): CompletableFuture<StytchResult<AuthorizeResponse>> =
        coroutineScope.async {
            authorize(data)
        }.asCompletableFuture()
}
