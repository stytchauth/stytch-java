package com.stytch.java.consumer.api.fraudfingerprint

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import com.squareup.moshi.Moshi
import com.stytch.java.common.InstantAdapter
import com.stytch.java.common.StytchResult
import com.stytch.java.consumer.models.fraudfingerprint.LookupRequest
import com.stytch.java.consumer.models.fraudfingerprint.LookupResponse
import com.stytch.java.http.HttpClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.future.asCompletableFuture
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.CompletableFuture

public interface Fingerprint {
    /**
     * Lookup the associated fingerprint for the `telemetry_id` returned from the `GetTelemetryID` function. Learn more about
     * the different fingerprint types and verdicts in our
     * [DFP guide](https://stytch.com/docs/fraud/guides/device-fingerprinting/overview).
     *
     * Make a decision based on the returned `verdict`:
     * * `ALLOW` - This is a known valid device grouping or device profile that is part of the default `ALLOW` listed set of
     * known devices by Stytch. This grouping is made up of  verified device profiles that match the characteristics of
     * known/authentic traffic origins.
     * * `BLOCK` - This is a known bad or malicious device profile that is undesirable and should be blocked from completing
     * the privileged action in question.
     * * `CHALLENGE` - This is an unknown or potentially malicious device that should be put through increased friction such
     * as 2FA or other forms of extended user verification before allowing the privileged action to proceed.
     *
     * If the `telemetry_id` is not found, we will return a 404 `telemetry_id_not_found`
     * [error](https://stytch.com/docs/fraud/api/errors/404#telemetry_id_not_found). We recommend treating 404 errors as a
     * `BLOCK`, since it could be a sign of an attacker trying to bypass DFP protections by generating fake telemetry IDs.
     */
    public suspend fun lookup(data: LookupRequest): StytchResult<LookupResponse>

    /**
     * Lookup the associated fingerprint for the `telemetry_id` returned from the `GetTelemetryID` function. Learn more about
     * the different fingerprint types and verdicts in our
     * [DFP guide](https://stytch.com/docs/fraud/guides/device-fingerprinting/overview).
     *
     * Make a decision based on the returned `verdict`:
     * * `ALLOW` - This is a known valid device grouping or device profile that is part of the default `ALLOW` listed set of
     * known devices by Stytch. This grouping is made up of  verified device profiles that match the characteristics of
     * known/authentic traffic origins.
     * * `BLOCK` - This is a known bad or malicious device profile that is undesirable and should be blocked from completing
     * the privileged action in question.
     * * `CHALLENGE` - This is an unknown or potentially malicious device that should be put through increased friction such
     * as 2FA or other forms of extended user verification before allowing the privileged action to proceed.
     *
     * If the `telemetry_id` is not found, we will return a 404 `telemetry_id_not_found`
     * [error](https://stytch.com/docs/fraud/api/errors/404#telemetry_id_not_found). We recommend treating 404 errors as a
     * `BLOCK`, since it could be a sign of an attacker trying to bypass DFP protections by generating fake telemetry IDs.
     */
    public fun lookup(
        data: LookupRequest,
        callback: (StytchResult<LookupResponse>) -> Unit,
    )

    /**
     * Lookup the associated fingerprint for the `telemetry_id` returned from the `GetTelemetryID` function. Learn more about
     * the different fingerprint types and verdicts in our
     * [DFP guide](https://stytch.com/docs/fraud/guides/device-fingerprinting/overview).
     *
     * Make a decision based on the returned `verdict`:
     * * `ALLOW` - This is a known valid device grouping or device profile that is part of the default `ALLOW` listed set of
     * known devices by Stytch. This grouping is made up of  verified device profiles that match the characteristics of
     * known/authentic traffic origins.
     * * `BLOCK` - This is a known bad or malicious device profile that is undesirable and should be blocked from completing
     * the privileged action in question.
     * * `CHALLENGE` - This is an unknown or potentially malicious device that should be put through increased friction such
     * as 2FA or other forms of extended user verification before allowing the privileged action to proceed.
     *
     * If the `telemetry_id` is not found, we will return a 404 `telemetry_id_not_found`
     * [error](https://stytch.com/docs/fraud/api/errors/404#telemetry_id_not_found). We recommend treating 404 errors as a
     * `BLOCK`, since it could be a sign of an attacker trying to bypass DFP protections by generating fake telemetry IDs.
     */
    public fun lookupCompletable(data: LookupRequest): CompletableFuture<StytchResult<LookupResponse>>
}

internal class FingerprintImpl(
    private val httpClient: HttpClient,
    private val coroutineScope: CoroutineScope,
) : Fingerprint {
    private val moshi = Moshi.Builder().add(InstantAdapter()).build()

    override suspend fun lookup(data: LookupRequest): StytchResult<LookupResponse> =
        withContext(Dispatchers.IO) {
            var headers = emptyMap<String, String>()

            val asJson = moshi.adapter(LookupRequest::class.java).toJson(data)
            httpClient.post("/v1/fingerprint/lookup", asJson, headers)
        }

    override fun lookup(
        data: LookupRequest,
        callback: (StytchResult<LookupResponse>) -> Unit,
    ) {
        coroutineScope.launch {
            callback(lookup(data))
        }
    }

    override fun lookupCompletable(data: LookupRequest): CompletableFuture<StytchResult<LookupResponse>> =
        coroutineScope.async {
            lookup(data)
        }.asCompletableFuture()
}
